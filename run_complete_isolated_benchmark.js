#!/usr/bin/env node
// Complete isolated benchmark system - integrates with existing infrastructure

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Create timestamped version directory
function createVersionDir() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const versionDir = path.join(__dirname, 'data', 'benchmark_runs', timestamp);
  
  if (!fs.existsSync(path.dirname(versionDir))) {
    fs.mkdirSync(path.dirname(versionDir), { recursive: true });
  }
  fs.mkdirSync(versionDir);
  
  console.log(`📂 Created benchmark version: ${timestamp}`);
  return { versionDir, timestamp };
}

// Run single competitor in isolated process
async function runIsolatedCompetitor(name, scriptPath) {
  console.log(`\\n${'='.repeat(50)}`);
  console.log(`🔬 ISOLATED: ${name.toUpperCase()}`);
  
  return new Promise((resolve, reject) => {
    const startTime = Date.now();
    
    const childProcess = spawn('node', [
      '--expose-gc',
      '--max-old-space-size=4096',
      '--no-warnings',
      scriptPath
    ], {
      stdio: ['pipe', 'pipe', 'pipe'],
      cwd: path.dirname(scriptPath),
      env: { ...process.env, NODE_ENV: 'isolated_benchmark' }
    });
    
    let output = '';
    let errorOutput = '';
    
    childProcess.stdout.on('data', (data) => {
      output += data.toString();
      // Show progress dots for long running benchmarks
      if (data.toString().includes('Progress:')) {
        process.stdout.write('.');
      }
    });
    
    childProcess.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });
    
    childProcess.on('exit', (code) => {
      const totalTime = Date.now() - startTime;
      console.log(`\\n⏱️  Completed in ${(totalTime/1000).toFixed(1)}s`);
      
      if (code !== 0) {
        console.error(`❌ Failed with code ${code}`);
        if (errorOutput) console.error(`Error: ${errorOutput}`);
        reject(new Error(`${name} failed`));
        return;
      }
      
      console.log(`✅ ${name} benchmark successful`);
      resolve({ output, totalTime });
    });
    
    // 10 minute timeout
    setTimeout(() => {
      if (!childProcess.killed) {
        console.log('⏰ Timeout - terminating process');
        childProcess.kill('SIGKILL');
        reject(new Error('Timeout'));
      }
    }, 600000);
  });
}

// Copy results to versioned directory
function archiveResults(versionDir, timestamp) {
  const resultFiles = [
    // MArrayCRDT results (run separately) 
    { src: 'simulation/marraycrdt_results.csv', dst: 'marraycrdt_results.csv' },
    { src: 'simulation/marraycrdt_comprehensive_benchmark.json', dst: 'marraycrdt_detailed.json' },
    
    // Individual competitor results (generated by isolated processes)
    { src: 'competitors/automerge/automerge_results.csv', dst: 'automerge_results.csv' },
    { src: 'competitors/yjs/yjs_results.csv', dst: 'yjs_results.csv' },
    { src: 'competitors/loro/loro_results.csv', dst: 'loro_results.csv' },
    { src: 'competitors/loro/loro_array_results.csv', dst: 'loro_array_results.csv' },
    { src: 'competitors/baseline/baseline_results.csv', dst: 'baseline_results.csv' }
  ];
  
  let copiedFiles = 0;
  const manifest = {
    version: timestamp,
    created: new Date().toISOString(),
    method: 'process_isolated',
    files: [],
    summary: {}
  };
  
  for (const { src, dst } of resultFiles) {
    const srcPath = path.join(__dirname, src);
    const dstPath = path.join(versionDir, dst);
    
    if (fs.existsSync(srcPath)) {
      try {
        fs.copyFileSync(srcPath, dstPath);
        const stats = fs.statSync(dstPath);
        manifest.files.push({
          name: dst,
          size: stats.size,
          originalPath: src
        });
        copiedFiles++;
        console.log(`  ✅ Archived: ${src} -> ${dst}`);
      } catch (error) {
        console.log(`  ⚠️  Failed to copy ${src}: ${error.message}`);
      }
    } else {
      console.log(`  ⚠️  Missing: ${src}`);
    }
  }
  
  // Create consolidated competitors CSV from individual files
  const competitorFiles = [
    { name: 'Automerge', file: path.join(versionDir, 'automerge_results.csv') },
    { name: 'Yjs', file: path.join(versionDir, 'yjs_results.csv') },
    { name: 'Loro', file: path.join(versionDir, 'loro_results.csv') },
    { name: 'LoroArray', file: path.join(versionDir, 'loro_array_results.csv') },
    { name: 'Baseline', file: path.join(versionDir, 'baseline_results.csv') }
  ];
  
  const consolidatedRows = ['system,operations,time_ms,ops_per_sec,memory_mb,final_length'];
  
  for (const { name, file } of competitorFiles) {
    if (fs.existsSync(file)) {
      try {
        const content = fs.readFileSync(file, 'utf8');
        const lines = content.trim().split('\\n').slice(1); // Skip header
        for (const line of lines) {
          if (line.includes(',') && !line.includes('system,operations')) {
            const parts = line.split(',');
            if (parts.length >= 5) {
              // Replace first column with consistent system name
              parts[0] = name;
              consolidatedRows.push(parts.join(','));
            }
          }
        }
      } catch (error) {
        console.log(`  ⚠️  Failed to process ${file}: ${error.message}`);
      }
    }
  }
  
  const consolidatedPath = path.join(versionDir, 'competitors_comparison.csv');
  fs.writeFileSync(consolidatedPath, consolidatedRows.join('\\n'));
  console.log(`  📊 Created consolidated: competitors_comparison.csv`);
  
  // Save manifest
  fs.writeFileSync(path.join(versionDir, 'manifest.json'), JSON.stringify(manifest, null, 2));
  console.log(`  📋 Generated manifest with ${copiedFiles} files`);
  
  return manifest;
}

// Update versions list
function updateVersionsList(versionDir, timestamp, manifest) {
  const versionsPath = path.join(__dirname, 'data', 'available_versions.json');
  
  let versions = [];
  if (fs.existsSync(versionsPath)) {
    try {
      versions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'));
    } catch (error) {
      console.log('Creating new versions list...');
    }
  }
  
  versions.unshift({
    version: timestamp,
    path: path.relative(__dirname, versionDir),
    created: new Date().toISOString(),
    method: 'process_isolated',
    fileCount: manifest.files.length
  });
  
  versions = versions.slice(0, 10); // Keep last 10 versions
  
  fs.writeFileSync(versionsPath, JSON.stringify(versions, null, 2));
  console.log(`📝 Updated versions list (${versions.length} versions available)`);
}

// Main execution
async function main() {
  console.log('🚀 PROCESS-ISOLATED CRDT BENCHMARK SUITE');
  console.log('Each competitor runs in a separate Node.js process');
  console.log('This provides reliable memory and timing measurements\\n');
  
  const { versionDir, timestamp } = createVersionDir();
  
  try {
    // Step 1: Run isolated competitor benchmarks
    console.log('📊 Step 1: Running isolated competitor benchmarks...');
    
    const competitors = [
      { name: 'Baseline', script: 'competitors/baseline/simulation.js' },
      { name: 'Automerge', script: 'competitors/automerge/simulation.js' },
      { name: 'Yjs', script: 'competitors/yjs/simulation.js' },
      { name: 'Loro', script: 'competitors/loro/simulation.js' },
      { name: 'LoroArray', script: 'competitors/loro/array_simulation.js' }
    ];
    
    for (let i = 0; i < competitors.length; i++) {
      const { name, script } = competitors[i];
      const scriptPath = path.join(__dirname, script);
      
      if (!fs.existsSync(scriptPath)) {
        console.log(`⚠️  Skipping ${name} - script not found`);
        continue;
      }
      
      try {
        // Wait between benchmarks for system cleanup
        if (i > 0) {
          console.log('\\n⏳ Waiting 5 seconds for system cleanup...');
          await new Promise(resolve => setTimeout(resolve, 5000));
        }
        
        await runIsolatedCompetitor(name, scriptPath);
        
      } catch (error) {
        console.error(`❌ ${name} failed: ${error.message}`);
        // Continue with other competitors
      }
    }
    
    console.log('\\n⏱️  Step 2: Running MArrayCRDT benchmark...');
    execSync('go run .', {
      cwd: path.join(__dirname, 'benchmarks'),
      stdio: 'inherit'
    });
    
    console.log('\\n📦 Step 3: Archiving results...');
    const manifest = archiveResults(versionDir, timestamp);
    
    console.log('\\n📚 Step 4: Updating versions registry...');
    updateVersionsList(versionDir, timestamp, manifest);
    
    console.log('\\n🎯 Process-isolated benchmark suite completed!');
    console.log(`\\n📂 Results archived in: ${path.relative(__dirname, versionDir)}`);
    console.log(`\\n🌐 Start web server to view results:`);
    console.log(`   cd web && npm start`);
    console.log('\\n✅ All benchmarks used process isolation for reliable measurements!');
    
    return versionDir;
    
  } catch (error) {
    console.error('❌ Benchmark suite failed:', error.message);
    
    // Still try to archive partial results
    try {
      console.log('🔄 Attempting to archive partial results...');
      const manifest = archiveResults(versionDir, timestamp);
      updateVersionsList(versionDir, timestamp, manifest);
      console.log('📦 Partial results archived');
    } catch (archiveError) {
      console.error('Failed to archive partial results:', archiveError.message);
    }
    
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { main };